!function (t, e) {
    "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.Bootstrapper = e() : t.Bootstrapper = e()
}(self, (function () {
    return function () {
        "use strict";
        var t = {
            d: function (e, i) {
                for (var o in i) t.o(i, o) && !t.o(e, o) && Object.defineProperty(e, o, {enumerable: !0, get: i[o]})
            }, o: function (t, e) {
                return Object.prototype.hasOwnProperty.call(t, e)
            }, r: function (t) {
                "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(t, "__esModule", {value: !0})
            }
        }, e = {};
        t.d(e, {
            default: function () {
                return H
            }
        });
        var i = {};
        t.r(i), t.d(i, {
            appendChild: function () {
                return b
            }, appendChildTo: function () {
                return f
            }, appendDivToBodyWithId: function () {
                return u
            }, createElement: function () {
                return h
            }, createElementLink: function () {
                return d
            }, createElementScript: function () {
                return c
            }, createScript: function () {
                return p
            }, createStyleSheet: function () {
                return l
            }, deepVal: function () {
                return s
            }, deepValWithBind: function () {
                return r
            }, documentCreateElement: function () {
                return g
            }, isSafari: function () {
                return o
            }, kebabCase: function () {
                return n
            }, merge: function () {
                return m
            }, noop: function () {
                return a
            }, resetDefaultStyles: function () {
                return S
            }, select: function () {
                return B
            }, selectMainInstanceWithMultiDestroy: function () {
                return v
            }
        });
        const o = () => /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);

        function n(t = "") {
            return t.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase()
        }

        const a = () => {
            }, s = (t, e = "") => e.split(".").reduce(((t, e) => t ? t[e] : t), t),
            r = (t, e = "") => e.split(".").reduce(((t, e) => {
                let i = t && t[e];
                return i = i && "function" == typeof i && "object" == typeof t ? i.bind(t) : i, i
            }), t);

        function l(t) {
            return d({href: t, rel: "stylesheet"})
        }

        function p(t) {
            return c({src: t})
        }

        function d(t) {
            return h("link", t)
        }

        function c(t) {
            return h("script", t)
        }

        function h(t, e) {
            return m(g(t), e)
        }

        const m = Object.assign;

        function g() {
            return document.createElement.apply(document, arguments)
        }

        function u(t) {
            return f("body", h("div", {id: t}))
        }

        function f(t, e) {
            return b(B(t), e)
        }

        function b(t, e) {
            return t.appendChild(e), e
        }

        function B(t) {
            return document.querySelector.apply(document, arguments)
        }

        function v(t, e, i = Function.prototype) {
            const o = t[e], n = Object.create(Object.getPrototypeOf(o)), a = Object.keys(t);
            return Object.assign(n, o, {
                destroy() {
                    a.forEach((e => {
                        t[e].destroy()
                    })), i()
                }
            }), a.forEach((i => {
                e !== i && (n[i] = t[i])
            })), n
        }

        function S(t, e) {
            Object.entries(e).forEach((([e, i]) => {
                t.style[e] = i || null
            }))
        }

        class w {
            constructor(t) {
                this.initProps(), this.postFix = t
            }

            initProps() {
                this.name = "", this.postFix = "", this.consoleTimeLabel = ""
            }

            timeEnd() {
                console.timeEnd(`${this.consoleTimeLabel}`)
            }

            time() {
                console.time(`${this.consoleTimeLabel}`)
            }

            initTimeLabel(t = this.name) {
                this.name = t;
                const e = this.postFix;
                this.consoleTimeLabel = `${t} ${e}`
            }
        }

        class y extends w {
            constructor() {
                super("config extracting"), this.initProps()
            }

            reset() {
                this.initProps()
            }

            initProps() {
                this.bootConfig = {}, this.bootableConfig = {}, this.name = null, this.url = null, this.urlWithVersion = null, this.indexHTMLUrl = null, this.indexHTML = null, this.globalSettings = {}, this.headElements = [], this.bodyElements = [], this.links = [], this.scripts = []
            }

            extract(t, e) {
                this.bootConfig = e, this.appConfig = t;
                const i = this.name = e.name;
                return this.appName = n(i), this.init(t.server)
            }

            async init(t) {
                return this.initServer(t), this.initGlobalSettings(), this.initName(), this.initTimeLabel(), this.time(), this.initGlobalSettingsEnv(), this.initUrlWithVersion(), await this.initElements(), this.initConfig(), this.timeEnd(), this.bootableConfig || {}
            }

            initConfig() {
                this.bootableConfig = {
                    name: this.name,
                    links: this.links,
                    scripts: this.scripts,
                    indexHTML: this.indexHTML,
                    globalSettings: this.globalSettings,
                    html: {head: this.headElements, body: this.bodyElements},
                    urls: {base: this.url, index: this.indexHTMLUrl, version: this.urlWithVersion}
                }
            }

            async initElements() {
                const {urlWithVersion: t, appName: e} = this, i = `${t}/${e}.min.js`, o = [l(`${t}/${e}.min.css`)],
                    n = [p(i)];
                this.assignToThis({headElements: o, bodyElements: n, links: o, scripts: n})
            }

            initGlobalSettings() {
                const {globalSettings: t} = this.appConfig;
                this.globalSettings = t
            }

            initUrlWithVersion() {
                let t = `https://${this.globalSettings.partner.CdnDomainName}/${this.appName}`,
                    e = this.bootConfig.version || this.globalSettings.projects[this.appName], i = e ? `${t}/${e}` : t;
                this.assignToThis({url: t, urlWithVersion: i})
            }

            initGlobalSettingsEnv() {
                let t = this.globalSettings, e = t.Env || (t.partner || {}).Env;
                this.assignToThis({globalSettingsEnv: e})
            }

            initName() {
                let t = this.bootConfig.name;
                this.assignToThis({name: t})
            }

            initServer(t) {
                this.server = t
            }

            assignToThis(t) {
                Object.assign(this, t)
            }

            destroy() {
                this.initProps()
            }
        }

        class C extends w {
            constructor() {
                super("loading"), this.initProps()
            }

            initProps() {
                super.initProps(), this.name = "", this.debug = !1, this.loadableElements = [], this.loadingDone = !1, this.onLoadResolve = a, this.onLoadComplete = () => {
                    this.loadingDone = !0, this.timeEnd(), this.onLoadResolve(this)
                }, this.bootableConfig = null
            }

            async load(t) {
                return this.name = t.name, this.debug = t.debug, this.initTimeLabel(), this.time(), this.bootableConfig = t, this.loadingDone = !1, this.initLoadableElements(), new Promise(((t, e) => {
                    this.onLoadResolve = t;
                    try {
                        this.loadElements()
                    } catch (t) {
                        e(t)
                    }
                }))
            }

            loadElements() {
                this.loadLinks(), this.loadScriptsSync()
            }

            loadScriptsSync(t = this.bootableConfig.scripts) {
                let e = t[0];
                this.loadScriptNext(e, t)
            }

            loadScriptNext(t, e = this.bootableConfig.scripts, i = 0) {
                if (!t) return this.onLoadComplete();
                t.onload = () => {
                    this.debug && console.timeEnd(`script ${i}`), this.loadScriptNext(e[++i], e, i)
                }, this.addScriptToDocument(t), this.debug && console.time(`script ${i}`), this.callScriptOnloadManuallyIfIsNotLoadable(t)
            }

            callScriptOnloadManuallyIfIsNotLoadable(t) {
                !this.loadableElements.includes(t) && t.onload()
            }

            addScriptToDocument(t) {
                t instanceof HTMLElement && f(this.bootableConfig.html.head.includes(t) ? "head" : "body", t)
            }

            removeScripts() {
                ((this.bootableConfig || {}).scripts || []).forEach((t => t.remove()))
            }

            loadLinks() {
                const t = document.head;
                this.bootableConfig.links.forEach((e => t.insertBefore(e, t.firstChild)))
            }

            removeLinks() {
                ((this.bootableConfig || {}).links || []).forEach((t => t.remove()))
            }

            initLoadableElements() {
                let t = this.bootableConfig.scripts.filter((t => t.src));
                this.loadableElements = t
            }

            destroy() {
                this.removeLinks(), this.removeScripts(), this.initProps()
            }
        }

        class E {
            constructor() {
                this.initProps()
            }

            async start(t) {
                return await this.callApplicationStartFunction(), this.afterLoadFunctions.forEach(Function.prototype.call), this
            }

            async setConfig(t) {
                this.initProps(), this.parent = t, this.afterLoadFunctions = [], this.appConfig = t.appConfig, this.bootConfig = t.bootConfig, this.init(), await this.callApplicationSetConfigFunction()
            }

            get iframe() {
                return this.parent.iframe
            }

            initProps() {
                this.parent = {}, this.afterLoadFunctions = [], this.appConfig = {}, this.bootConfig = {}, this.appStarterImplemented = !1, this.hostObject = {}, this.appStarter = {}
            }

            addEventListener(t, e) {
                const i = this, o = this.iframe, n = this.bootConfig.name.toLowerCase();

                function a(o) {
                    if (!i.iframe) return window.removeEventListener("message", a);
                    const s = o.data, r = s.sender && s.sender !== n;
                    s.type !== t || r || (i.iframe.contentWindow && i.iframe.contentWindow.postMessage(o.data, "*"), e(s))
                }

                return o ? window.addEventListener("message", a) : this.callAppStarterMethod((() => this.appStarter.addEventListener(t, e))), () => this.removeEventListener(t, a)
            }

            removeEventListener(t, e) {
                const i = this.iframe;
                i ? i.removeEventListener(t, e) : this.callAppStarterMethod((() => this.appStarter.removeEventListener(t, e)))
            }

            dispatchEvent(t, e) {
                const i = this.iframe, o = this.bootConfig.name.toLowerCase();
                if (i) {
                    const n = i.contentWindow;
                    n && n.postMessage({data: e, sender: "bootstrapper", receiver: o, type: t}, "*")
                } else this.callAppStarterMethod((() => this.appStarter.dispatchEvent(t, e)))
            }

            callAppStarterMethod(t) {
                void 0 === this.appStarterImplemented ? this.afterLoadFunctions.push(t) : this.appStarterImplemented ? t() : console.warn("%cAppStarter is not implemented. For messaging system please implement `@sportdigi/app-starter` in your application.", "color: orange")
            }

            async callApplicationStartFunction() {
                return await this.callApplicationMethod("start")
            }

            async callApplicationSetConfigFunction() {
                return await this.callApplicationMethod("setConfig")
            }

            async callApplicationMethod(t) {
                let e = this.parent, i = this.appConfig, o = this.appStarter;
                if (!o[t]) return this.bootConfig.debug && console.warn(t, "not found in", o);
                const n = Object.assign(i, {container: i.containerId});
                return o[t](n, e)
            }

            init() {
                this.initHostObject(), this.initAppStarter(), this.guessAppStarterIfNotFound(), this.guessAppDestroyIfNotFound()
            }

            initHostObject() {
                this.hostObject = this.iframe ? this.iframe.contentWindow : window
            }

            initAppStarter() {
                const t = this.hostObject, e = this.bootConfig.name, i = n(e), o = t.sportdigi;
                if (o) {
                    const t = o[i];
                    if (t) {
                        if (t.addEventListener) return this.appStarterImplemented = !0, this.appStarter = t;
                        this.appStarterImplemented = !1
                    }
                }
                const r = s(t, e || "") || a;
                this.appStarter = {start: r}
            }

            guessAppStarterIfNotFound() {
                const t = this.appStarter.start, e = this.bootConfig.name, i = this.hostObject,
                    o = this.bootConfig.appStarterName;
                if (t !== a || o) return;
                const s = n(e);
                this.appStarter = r(i, `sportdigi.${s}`) || {
                    start: function () {
                        console.log("App starter function not found. Try to set parameter `appStarterName`")
                    }
                }
            }

            guessAppDestroyIfNotFound() {
                const t = this.appStarter.destroy, e = this.hostObject, i = this.bootConfig.name;
                if (t !== a) return;
                const o = n(i);
                this.appStarter.destroy = r(e, "AppStarter.destroy") || r(e, `DIGI.${i}.destroy`) || r(e, `sportdigi.${o}.destroy`) || function () {
                    console.log("App starter destroy function not found.")
                }
            }

            destroy() {
                this.appStarter.destroy && this.appStarter.destroy(), this.initProps()
            }
        }

        const T = {
            server: "",
            sportPartner: "",
            isBetShop: !1,
            token: "-",
            timeZone: "",
            defaultLanguage: "",
            userId: "",
            globalSettings: null,
            requestFrame: null,
            translations: null,
            initialized: !1,
            resolved: !1
        };

        async function I(t) {
            return async function (t) {
                return function (t = {}) {
                    Object.entries(t).forEach((([t, e]) => {
                        T.hasOwnProperty(t) && (T[t] = e)
                    })), T.defaultLanguage = ["language", "defaultLanguage", "l", "lang"].map((e => t[e])).find(Boolean);
                    let e = T.server;
                    e && (e.endsWith("/") && (e = e.slice(0, -1)), e.includes("//") && (e = e.split("//")[1]), T.server = `https://${e}`, T.initialized = !0)
                }(t), M(), await async function () {
                    const {server: t, sportPartner: e} = T;
                    let i = "request-frame", o = document.getElementById(i);
                    if (!o) {
                        o = document.createElement("iframe"), o.id = i, o.style.display = "none";
                        let n = `${t}/Tools/RequestHelper`;
                        e && (n += `?id=${e}`), o.src = n, await new Promise((t => {
                            ["complete", "loaded", "interactive"].includes(document.readyState) ? L(o, t) : document.addEventListener("DOMContentLoaded", (() => {
                                L(o, t)
                            }))
                        }))
                    }
                    return T.requestFrame || (T.requestFrame = o), Promise.resolve()
                }(), (!T.resolved || "-" !== T.token && !T.globalSettings.jwt) && (await async function () {
                    const {defaultLanguage: t, isBetShop: e, token: i, timeZone: o} = T;
                    let n = {
                        sender: "http-api",
                        url: "/Account/Authorize",
                        finalParams: {
                            data: {partnerUserId: T.userId, token: i, l: t, tz: o, userTypeId: e ? 7 : 2},
                            path: "Account/Authorize",
                            method: "get",
                            params: [["partnerUserId", "long?"], ["userTypeId", "int?"], ["token", "string"], ["l", "string"], ["tz", "double"]]
                        }
                    };
                    await F(n).then((t => {
                        T.globalSettings = t
                    }))
                }(), await async function () {
                    const {globalSettings: {partner: t = {}, language: e = {}}} = T;
                    let i = {
                        sender: "http-api",
                        url: "/StaticContent/GetJs",
                        finalParams: {
                            data: {language: e.TwoLetterName, partnerId: t.Id},
                            path: "StaticContent/GetJs",
                            method: "get",
                            params: [["language", "string"], ["partnerId", "int?"]]
                        }
                    };
                    await F(i).then((t => {
                        T.translations = t
                    }))
                }()), T.resolved = !0, {translations: T.translations, globalSettings: T.globalSettings}
            }(t)
        }

        function M(t = !1) {
            if (!T.initialized) return;
            const {server: e} = T;
            if (t) return O(e);
            let i = sessionStorage.getItem("__sb_err_cnt__");
            i = parseInt(i), isNaN(i) && (i = 0), i < 3 && fetch(e + "/Error/Check", {
                method: "GET",
                mode: "cors",
                credentials: "include"
            }).catch((() => {
                sessionStorage.setItem("__sb_err_cnt__", ++i), O(e)
            }))
        }

        function O(t) {
            return location.href = t + "/Error/Validate?returnUrl=" + encodeURIComponent(location.href)
        }

        function L(t, e) {
            t.onload = function () {
                t.isSportFrameLoaded = !0, e()
            }, document.body.appendChild(t)
        }

        async function F(t = {}) {
            return t.messageId = t.url + Math.random(), t.finalParams.headers = {}, new Promise(((e, i) => {
                const o = t.messageId;
                let n = t => {
                    t.data && "object" == typeof t.data && "http-api-response" === t.data.sender && t.data.messageId === o && (window.removeEventListener("message", n), t.data.ok || i(t.data), e(t.data.res))
                };
                window.addEventListener("message", n), T.requestFrame.contentWindow.postMessage(t, "*")
            }))
        }

        class x {
            constructor(t = {}) {
                this.init.apply(this, arguments)
            }

            static get version() {
                return "6.4.1"
            }

            static get Utils() {
                return i
            }

            static async bootLatinoView(t = {}, e = {}) {
                t.globalSettings.user && t.globalSettings.user.UserSetting && (t.globalSettings.user.UserSetting.OddFormat = 0);
                const i = t.containerId, o = document.getElementById(i),
                    n = h("div", {id: "latino-view-container-element"});
                Object.assign(n.style, {position: "relative", zIndex: "1", height: "100%"});
                const a = h("div", {id: "betslip-container-element"});
                Object.assign(a.style, {
                    position: "fixed",
                    width: "100%",
                    bottom: "0",
                    zIndex: "9999"
                }), o.appendChild(n), o.appendChild(a);
                const s = {
                    ...t,
                    apps: [{
                        appConfig: {...t, containerId: n.id},
                        bootConfig: {...e, name: "LatinoView"},
                        method: `${e.method}Base`,
                        listen: {
                            Betslip: {
                                navigateToEvent: (t, {data: e}) => {
                                    t.dispatch("navigateToEvent", e)
                                }, openBetHistory: (t, {}) => {
                                    t.dispatch("openBetHistory", null)
                                }, betSlipUpdate: (t, {data: e}) => {
                                    t.dispatch("betSlipUpdate", e)
                                }, login: () => {
                                    t.login()
                                }, placeBetSuccess: (t, {data: e}) => {
                                    t.dispatch("placeBetSuccess", e)
                                }
                            }
                        }
                    }, {
                        appConfig: {
                            container: a,
                            width: 360,
                            maxHeight: .8 * window.innerHeight,
                            minHeight: 200,
                            closeModeVariant: 0,
                            animated: !0,
                            bookBetHide: !0,
                            position: t.globalSettings.partner.BetslipPosition,
                            viewType: 1
                        },
                        bootConfig: {name: "Betslip"},
                        method: "bootIframe",
                        listen: {
                            Betslip: {
                                navigateToEvent: t => {
                                    t.dispatch("closeBetSlip", null)
                                }, login: t => {
                                    t.dispatch("closeBetSlip", null)
                                }
                            }, LatinoView: {
                                toggleStake: (t, {data: e}) => {
                                    t.dispatch("toggleStake", e)
                                }, updateUserBalance: (t, {data: e}) => {
                                    t.dispatch("updateUserBalance", e)
                                }, chequeRedactOrder: (t, {data: e}) => {
                                    t.dispatch("chequeRedactOrder", e)
                                }, repeatTheBet: (t, {data: e}) => {
                                    t.dispatch("repeatTheBet", e)
                                }, loadExpressOfTheDay: (t, {data: e}) => {
                                    t.dispatch("loadExpressOfTheDay", e)
                                }, clearBetSlip: t => {
                                    t.dispatch("clearBetSlip")
                                }, bookBet: (t, {data: e}) => {
                                    t.dispatch("loadBookedBet", e)
                                }, openBetSlip: t => {
                                    t.dispatch("openBetSlip", null)
                                }, closeBetSlip: t => {
                                    t.dispatch("closeBetSlip", null)
                                }, updateOddFormat: (t, {data: e}) => {
                                    t.dispatch("updateOddFormat", e)
                                }, toggleBetSlipVisibility: (t, {data: e}) => {
                                    e ? (t.dispatch("closeBetSlip", null), t.dispatch("hideCloseMode", null)) : t.dispatch("showCloseMode", null)
                                }
                            }
                        }
                    }]
                };
                return await x.multiBoot(s, e.name, (() => {
                    n.remove(), a.remove()
                }))
            }

            static async bootBetShop(t = {}, e = {}) {
                t.globalSettings.user && t.globalSettings.user.UserSetting && (t.globalSettings.user.UserSetting.OddFormat = 0);
                const i = [], {mirroringScriptUrl: o} = t;
                o && i.push(o);
                const n = t.containerId, a = document.getElementById(n),
                    s = h("div", {id: "bet-shop-container-element"});
                Object.assign(s.style, {position: "relative", zIndex: "1", height: "100%"});
                const r = h("div", {id: "betslip-container-element"});
                Object.assign(r.style, {
                    position: "fixed",
                    width: "100%",
                    bottom: "0",
                    zIndex: "9999"
                }), a.appendChild(s), a.appendChild(r);
                const l = {
                    ...t,
                    apps: [{
                        appConfig: {...t, containerId: s.id},
                        bootConfig: {...e, name: "BetShop"},
                        method: `${e.method}Base`,
                        listen: {
                            Betslip: {
                                navigateToEvent: (t, {data: e}) => {
                                    t.dispatch("navigateToEvent", e)
                                }, openBetHistory: (t, {}) => {
                                    t.dispatch("openBetHistory", null)
                                }, betSlipUpdate: (t, {data: e}) => {
                                    t.dispatch("betSlipUpdate", e)
                                }, login: () => {
                                    t.login()
                                }, placeBetSuccess: (t, {data: e}) => {
                                    t.dispatch("placeBetSuccess", e)
                                }
                            }
                        }
                    }, {
                        appConfig: {
                            container: r,
                            width: 360,
                            maxHeight: .8 * window.innerHeight,
                            minHeight: 200,
                            closeModeVariant: 0,
                            animated: !0,
                            bookBetHide: !0,
                            position: t.globalSettings.partner.BetslipPosition,
                            viewType: 1,
                            scriptUrls: i
                        },
                        bootConfig: {name: "Betslip"},
                        method: "bootIframe",
                        listen: {
                            Betslip: {
                                navigateToEvent: t => {
                                    t.dispatch("closeBetSlip", null)
                                }, login: t => {
                                    t.dispatch("closeBetSlip", null)
                                }
                            }, BetShop: {
                                toggleStake: (t, {data: e}) => {
                                    t.dispatch("toggleStake", e)
                                }, updateUserBalance: (t, {data: e}) => {
                                    t.dispatch("updateUserBalance", e)
                                }, chequeRedactOrder: (t, {data: e}) => {
                                    t.dispatch("chequeRedactOrder", e)
                                }, repeatTheBet: (t, {data: e}) => {
                                    t.dispatch("repeatTheBet", e)
                                }, loadExpressOfTheDay: (t, {data: e}) => {
                                    t.dispatch("loadExpressOfTheDay", e)
                                }, clearBetSlip: t => {
                                    t.dispatch("clearBetSlip")
                                }, bookBet: (t, {data: e}) => {
                                    t.dispatch("loadBookedBet", e)
                                }, openBetSlip: t => {
                                    t.dispatch("openBetSlip", null)
                                }, closeBetSlip: t => {
                                    t.dispatch("closeBetSlip", null)
                                }, updateOddFormat: (t, {data: e}) => {
                                    t.dispatch("updateOddFormat", e)
                                }, toggleBetSlipVisibility: (t, {data: e}) => {
                                    e ? (t.dispatch("closeBetSlip", null), t.dispatch("hideCloseMode", null)) : t.dispatch("showCloseMode", null)
                                }
                            }
                        }
                    }]
                };
                return await x.multiBoot(l, e.name, (() => {
                    s.remove(), r.remove()
                }))
            }

            static async bootEuropeanView(t = {}, e = {}) {
                const i = t.containerId, o = document.getElementById(i),
                    n = h("div", {id: "european-view-container-element"});
                Object.assign(n.style, {position: "relative", zIndex: "1", height: "100%"});
                const a = h("div", {id: "betslip-container-element"});
                Object.assign(a.style, {
                    position: "fixed",
                    width: "100%",
                    bottom: "0",
                    zIndex: "9999"
                }), o.appendChild(n), o.appendChild(a);
                const s = {
                    ...t,
                    apps: [{
                        appConfig: {...t, containerId: n.id},
                        bootConfig: {...e, name: "EuropeanView"},
                        method: `${e.method}Base`,
                        listen: {
                            Betslip: {
                                navigateToEvent: (t, {data: e}) => {
                                    t.dispatch("navigateToEvent", e)
                                }, betSlipUpdate: (t, {data: e}) => {
                                    t.dispatch("betSlipUpdate", e)
                                }, login: () => {
                                    t.login()
                                }, placeBetSuccess: (t, {data: e}) => {
                                    t.dispatch("placeBetSuccess", e)
                                }
                            }
                        }
                    }, {
                        appConfig: {
                            container: a,
                            width: 360,
                            maxHeight: .8 * window.innerHeight,
                            minHeight: 200,
                            closeModeVariant: 0,
                            animated: !0,
                            bookBetHide: !0,
                            position: t.globalSettings.partner.BetslipPosition,
                            viewType: 1
                        },
                        bootConfig: {name: "Betslip"},
                        method: "bootIframe",
                        listen: {
                            Betslip: {
                                navigateToEvent: t => {
                                    t.dispatch("closeBetSlip", null)
                                }, login: t => {
                                    t.dispatch("closeBetSlip", null)
                                }
                            }, EuropeanView: {
                                toggleStake: (t, {data: e}) => {
                                    console.log(e, "----"), t.dispatch("toggleStake", e)
                                }, updateUserBalance: (t, {data: e}) => {
                                    t.dispatch("updateUserBalance", e)
                                }, chequeRedactOrder: (t, {data: e}) => {
                                    t.dispatch("chequeRedactOrder", e)
                                }, repeatTheBet: (t, {data: e}) => {
                                    t.dispatch("repeatTheBet", e)
                                }, loadExpressOfTheDay: (t, {data: e}) => {
                                    t.dispatch("loadExpressOfTheDay", e)
                                }, bookBet: (t, {data: e}) => {
                                    t.dispatch("loadBookedBet", e)
                                }, openBetSlip: t => {
                                    t.dispatch("openBetSlip", null)
                                }, closeBetSlip: t => {
                                    t.dispatch("closeBetSlip", null)
                                }
                            }
                        }
                    }]
                };
                return await x.multiBoot(s, e.name, (() => {
                    n.remove(), a.remove()
                }))
            }

            static async bootModernView(t = {}, e = {}) {
                const i = t.containerId, o = document.getElementById(i),
                    n = h("div", {id: "modern-view-container-element"});
                Object.assign(n.style, {position: "relative", zIndex: "1", height: "100%"});
                const a = h("div", {id: "betslip-container-element"});
                Object.assign(a.style, {
                    position: "fixed",
                    width: "100%",
                    bottom: "0",
                    zIndex: "9999"
                }), o.appendChild(n), o.appendChild(a);
                const s = {
                    ...t,
                    apps: [{
                        appConfig: {...t, containerId: n.id},
                        bootConfig: {...e, name: "ModernView"},
                        method: `${e.method}Base`,
                        listen: {
                            Betslip: {
                                navigateToEvent: (t, {data: e}) => {
                                    t.dispatch("navigateToEvent", e)
                                }, betSlipUpdate: (t, {data: e}) => {
                                    t.dispatch("betSlipUpdate", e)
                                }, login: () => {
                                    t.login()
                                }, placeBetSuccess: (t, {data: e}) => {
                                    t.dispatch("placeBetSuccess", e)
                                }
                            }
                        }
                    }, {
                        appConfig: {
                            container: a,
                            width: 360,
                            maxHeight: .8 * window.innerHeight,
                            minHeight: 200,
                            closeModeVariant: 0,
                            animated: !0,
                            bookBetHide: !0,
                            position: t.globalSettings.partner.BetslipPosition,
                            viewType: 1
                        },
                        bootConfig: {name: "Betslip"},
                        method: "bootIframe",
                        listen: {
                            Betslip: {
                                navigateToEvent: t => {
                                    t.dispatch("closeBetSlip", null)
                                }, login: t => {
                                    t.dispatch("closeBetSlip", null)
                                }
                            }, ModernView: {
                                toggleStake: (t, {data: e}) => {
                                    t.dispatch("toggleStake", e)
                                }, updateUserBalance: (t, {data: e}) => {
                                    t.dispatch("updateUserBalance", e)
                                }, chequeRedactOrder: (t, {data: e}) => {
                                    t.dispatch("chequeRedactOrder", e)
                                }, repeatTheBet: (t, {data: e}) => {
                                    t.dispatch("repeatTheBet", e)
                                }, loadExpressOfTheDay: (t, {data: e}) => {
                                    t.dispatch("loadExpressOfTheDay", e)
                                }, bookBet: (t, {data: e}) => {
                                    t.dispatch("loadBookedBet", e)
                                }, openBetSlip: t => {
                                    t.dispatch("openBetSlip", null)
                                }, closeBetSlip: t => {
                                    t.dispatch("closeBetSlip", null)
                                }, openSystemCalculator: t => {
                                    t.dispatch("openSystemCalculator", null)
                                }
                            }
                        }
                    }]
                };
                return await x.multiBoot(s, e.name, (() => {
                    n.remove(), a.remove()
                }))
            }

            static async bootBetSlip(t, e = {}) {
                const i = "betslip-root-inner", o = h("div", {id: i}),
                    n = t.container instanceof HTMLElement ? t.container : document.body, a = t.position,
                    s = t.globalSettings.language.IsRTL, r = {
                        1: s ? {right: "0"} : {left: "0"},
                        2: {left: "50%", transform: "translateX(-50%)", transition: "all 1s ease 0s"},
                        3: s ? {left: "0"} : {right: "0"}
                    }[{center: 2, right: 3, left: 1}[a] || 3] || {};
                let l = {
                    position: "absolute",
                    bottom: "0",
                    width: ("number" == typeof t.width ? `${t.width}px` : t.width) || "100%",
                    overflow: "hidden", ...r
                };
                Object.assign(o.style, l), x.Utils.appendChild(n, o);
                const p = Object.assign(t, {
                    maxHeight: t.isMobile || t.maxHeight ? t.maxHeight : .8 * window.innerHeight,
                    minHeight: t.isMobile || t.minHeight ? t.minHeight : 200,
                    containerId: i,
                    betSlipRootStyle: l
                }), d = Object.assign(e, {name: "Betslip"}), c = await x.bootIframeBase(p, d, {height: "1"});
                let m = t.closeModeVariant;
                return c.addEventListener("updateCloseModeVariant", (({data: t}) => {
                    m = t
                })), c.addEventListener("sizeChange", (({data: t}) => {
                    c.iframe.style.height = `${t.height}px`, c.dispatch("opacity", 1), window.innerWidth > 1200 && Object.assign(o.style, l)
                })), c.addEventListener("open", (() => {
                    1 === m && Object.assign(o.style, l)
                })), c.addEventListener("close", (() => {
                    1 === m && Object.assign(o.style, {
                        width: "120px",
                        bottom: "140px"
                    }), window.innerWidth > 1200 && Object.assign(o.style, l)
                })), c
            }

            static async bootAsianViewWithNewBetslip(t = {}, e = {}) {
                const i = t.containerId, o = document.getElementById(i), n = h("div", {id: "asian-view-container"}),
                    a = h("div", {id: "betslip-container"});
                Object.assign(n.style, {position: "relative", zIndex: "1"}), Object.assign(a.style, {
                    position: "fixed",
                    width: "90%",
                    bottom: "0",
                    zIndex: "2"
                }), o.appendChild(n), o.appendChild(a);
                const s = {
                    ...t,
                    communication: [{
                        from: "Betslip",
                        to: "AsianView",
                        eventFrom: "showQuickDepositPopUp",
                        eventTo: (t, e) => t.starter.dispatchEvent("showQuickDepositPopUp", e)
                    }, {
                        from: "Betslip",
                        to: "AsianView",
                        eventFrom: "lowMoney",
                        eventTo: (t, e) => t.starter.dispatchEvent("lowMoney", e)
                    }, {from: "Betslip", to: "AsianView", eventFrom: "login", eventTo: "login"}, {
                        from: "Betslip",
                        to: "AsianView",
                        eventFrom: "betSlipUpdate",
                        eventTo: "betSlipUpdate"
                    }, {
                        from: "Betslip",
                        to: "AsianView",
                        eventFrom: "navigateToEvent",
                        eventTo: "navigateToEvent"
                    }, {
                        from: "Betslip",
                        to: "AsianView",
                        eventFrom: "placeBetSuccess",
                        eventTo: "placeBetSuccess"
                    }, {
                        from: "Betslip",
                        to: "AsianView",
                        eventFrom: "openBetHistory",
                        eventTo: "openBetHistory"
                    }, {
                        from: "AsianView",
                        to: "Betslip",
                        eventFrom: "toggleStake",
                        eventTo: "toggleStake"
                    }, {
                        from: "AsianView",
                        to: "Betslip",
                        eventFrom: "chequeRedactOrder",
                        eventTo: "chequeRedactOrder"
                    }, {
                        from: "AsianView",
                        to: "Betslip",
                        eventFrom: "updateUserBalance",
                        eventTo: "updateUserBalance"
                    }, {from: "AsianView", to: "Betslip", eventFrom: "updateOddFormat", eventTo: "updateOddFormat"}],
                    apps: [{
                        appConfig: {...t, containerId: n.id, newBetSlip: !0},
                        bootConfig: {...e, name: "AsianView", newBetSlip: !1},
                        method: e.method || "boot"
                    }, {
                        appConfig: {
                            container: a,
                            width: 400,
                            maxHeight: .7 * window.innerHeight,
                            position: t.globalSettings.partner.BetslipPosition,
                            bookBetHide: !0,
                            formattingOnlySingleMode: !0,
                            preventFormattingSpecialMarkets: !0,
                            viewType: 2
                        }, bootConfig: {name: "Betslip"}, method: "bootIframe"
                    }]
                };
                return await x.multiBoot(s, e.name, (() => {
                    o.remove()
                }))
            }

            static async bootMobileWithNewBetslip(t = {}, e = {}) {
                const i = B(`#${t.containerId}`), o = h("div", {id: "root-element", style: "height: 100%"}),
                    n = h("div", {id: "mobile-container-element"});
                Object.assign(n.style, {position: "relative", zIndex: "1"});
                const a = h("div", {id: "betslip-container-element"});
                Object.assign(a.style, {
                    position: "fixed",
                    width: "100%",
                    bottom: "0",
                    zIndex: "1990"
                }), o.appendChild(n), document.body.appendChild(a), i.appendChild(o);
                const s = {
                    ...t,
                    communication: [{
                        from: "Betslip",
                        to: "Mobile",
                        eventFrom: "toggleTournamentWallet",
                        eventTo: "toggleTournamentTab"
                    }, {
                        from: "Betslip",
                        to: "Mobile",
                        eventFrom: "navigateToEvent",
                        eventTo: "navigateToEvent"
                    }, {from: "Betslip", to: "Mobile", eventFrom: "login", eventTo: "login"}, {
                        from: "Betslip",
                        to: "Mobile",
                        eventFrom: "showQuickDepositPopUp",
                        eventTo: "showQuickDepositPopUp"
                    }, {
                        from: "Betslip",
                        to: "Mobile",
                        eventFrom: "openBetHistory",
                        eventTo: "openBetHistory"
                    }, {from: "Betslip", to: "Mobile", eventFrom: "bookBet", eventTo: "showBookBet"}, {
                        from: "Betslip",
                        to: "Mobile",
                        eventFrom: "lowMoney",
                        eventTo: "lowMoney"
                    }, {
                        from: "Betslip",
                        to: "Mobile",
                        eventFrom: "placeBetSuccess",
                        eventTo: "getUserBalance"
                    }, {
                        from: "Betslip",
                        to: "Betslip",
                        eventFrom: "navigateToEvent",
                        eventTo: "closeBetSlip"
                    }, {from: "Betslip", to: "Betslip", eventFrom: "login", eventTo: "closeBetSlip"}, {
                        from: "Betslip",
                        to: "Betslip",
                        eventFrom: "openBetHistory",
                        eventTo: "closeBetSlip"
                    }, {
                        from: "Betslip",
                        to: "Betslip",
                        eventFrom: "showBetHistoryPopUp",
                        eventTo: "closeBetSlip"
                    }, {
                        from: "Betslip",
                        to: "Betslip",
                        eventFrom: "bookBet",
                        eventTo: "closeBetSlip"
                    }, {from: "Betslip", to: "Mobile", eventFrom: "sizeChange", eventTo: "sizeChange"}, {
                        from: "Mobile",
                        to: "Betslip",
                        eventFrom: "addStake",
                        eventTo: "toggleStake"
                    }, {
                        from: "Mobile",
                        to: "Betslip",
                        eventFrom: "betSlipClicked",
                        eventTo: "openBetSlip"
                    }, {
                        from: "Mobile",
                        to: "Betslip",
                        eventFrom: "removeStake",
                        eventTo: "toggleStake"
                    }, {
                        from: "Mobile",
                        to: "Betslip",
                        eventFrom: "chequeRedactOrder",
                        eventTo: "chequeRedactOrder"
                    }, {
                        from: "Mobile",
                        to: "Betslip",
                        eventFrom: "loadExpressOfTheDay",
                        eventTo: "loadExpressOfTheDay"
                    }, {
                        from: "Mobile",
                        to: "Betslip",
                        eventFrom: "tournamentToggle",
                        eventTo: "setSportTournamentMode"
                    }, {from: "Mobile", to: "Betslip", eventFrom: "bookBet", eventTo: "loadBookedBet"}, {
                        from: "Mobile",
                        to: "Betslip",
                        eventFrom: "changeOddFormat",
                        eventTo: "updateOddFormat"
                    }, {
                        from: "Mobile",
                        to: "Betslip",
                        eventFrom: "changeTimeFormat",
                        eventTo: "updateTimeFormat"
                    }, {
                        from: "Mobile",
                        to: "Betslip",
                        eventFrom: "updateUserBalance",
                        eventTo: "updateUserBalance"
                    }, {
                        from: "Betslip",
                        to: "Mobile",
                        eventFrom: "betSlipUpdate",
                        eventTo: (t, e) => t.dispatch("updateBetSlip", e.betSlip)
                    }, {
                        from: "Mobile",
                        to: "Betslip",
                        eventFrom: "repeatTheBet",
                        eventTo: (t, e) => t.dispatch("repeatTheBet", {betnumber: e.checknumber, gameType: e.gameType})
                    }, {
                        from: "Mobile",
                        to: "Betslip",
                        eventFrom: "resize",
                        eventTo: t => t.dispatch("updateHeight", window.innerHeight)
                    }, {
                        from: "Mobile",
                        to: "Betslip",
                        eventFrom: "betSlipPinVisibility",
                        eventTo: (t, e) => t.dispatch(e ? "showCloseMode" : "hideCloseMode", null)
                    }, {
                        from: "Mobile", to: "Betslip", eventFrom: "networkAvailability", eventTo: (t, e) => {
                            e ? t.dispatch("showCloseMode", null) : (t.dispatch("closeBetSlip", null), t.dispatch("hideCloseMode", null))
                        }
                    }],
                    apps: [{
                        appConfig: {...t, containerId: n.id, newBetSlip: !0},
                        bootConfig: {...e, name: "Mobile", newBetSlip: !1},
                        method: e.method || "boot"
                    }, {
                        appConfig: {
                            container: a,
                            height: window.innerHeight,
                            animated: !1,
                            borderRadius: 0,
                            position: 3,
                            isMobile: !0,
                            closeModeVariant: t.bottomNavBar ? 2 : 1,
                            viewType: "asian" === t.view ? 2 : 1,
                            applicationType: 3
                        }, bootConfig: {name: "Betslip"}, method: "bootIframe"
                    }]
                }, r = await x.multiBoot(s, e.name, (() => {
                    n.remove(), a.remove()
                }));
                return r.Betslip.addEventListener("open", (({data: t}) => {
                    "standard" === t.betSlipMode && (() => {
                        const t = document.body, e = {
                            position: t.style.position,
                            top: t.style.top,
                            right: t.style.right,
                            bottom: t.style.bottom,
                            left: t.style.left
                        }, i = () => {
                            S(t, e), r.Betslip.removeEventListener("close", i)
                        };
                        Object.assign(t.style, {
                            position: "fixed",
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        }), r.Betslip.addEventListener("close", i)
                    })()
                })), r.Betslip.dispatch("updateHeight", window.innerHeight), r
            }

            static async bootESport(t = {}, e = {}) {
                const i = t.containerId, o = document.getElementById(i), n = window.innerWidth > 1200,
                    a = h("div", {id: "e-sport-container-element"}), s = h("div", {id: "betslip-container-element"});
                Object.assign(a.style, {position: "relative", zIndex: "1"}), Object.assign(s.style, {
                    position: "fixed",
                    width: "100%",
                    bottom: "0",
                    zIndex: "1990",
                    right: "0"
                }), o.appendChild(a), n ? o.appendChild(s) : document.body.appendChild(s);
                const r = {
                    container: s,
                    width: 360,
                    maxHeight: .8 * window.innerHeight,
                    minHeight: 200,
                    height: null,
                    closeModeVariant: 0,
                    animated: !0,
                    position: t.globalSettings.partner.BetslipPosition,
                    bookBetHide: !0,
                    viewType: 5
                };
                n || Object.assign(r, {
                    width: null,
                    maxHeight: null,
                    minHeight: null,
                    height: window.innerHeight,
                    closeModeVariant: 1,
                    animated: !1,
                    position: 3,
                    borderRadius: 0,
                    isMobile: !0
                });
                const l = {
                    ...t,
                    apps: [{
                        appConfig: {...t, containerId: a.id, newBetSlip: !0},
                        bootConfig: {...e, name: "ESport", newBetSlip: !1},
                        method: e.method + "Base",
                        listen: {
                            Betslip: {
                                navigateToEvent: (t, {data: e}) => {
                                    t.dispatch("navigateToEvent", e)
                                }, betSlipUpdate: (t, {data: e}) => {
                                    t.dispatch("betSlipUpdate", e)
                                }, showQuickDepositPopUp: (t, {data: e}) => {
                                    t.dispatch("showQuickDepositPopUp", e)
                                }, openBetHistory: t => {
                                    t.dispatch("openBetHistory", null)
                                }, login: () => {
                                    let e = () => {
                                    };
                                    "function" == typeof t.login ? e = t.login : "function" == typeof t.loginTrigger && (e = t.loginTrigger), e()
                                }, placeBetSuccess: (t, {data: e}) => {
                                    t.dispatch("placeBetSuccess", e)
                                }
                            }
                        }
                    }, {
                        appConfig: r,
                        bootConfig: {name: "Betslip"},
                        method: "bootIframe",
                        listen: {
                            Betslip: {
                                navigateToEvent: t => {
                                    t.dispatch("closeBetSlip", null)
                                }, login: t => {
                                    t.dispatch("closeBetSlip", null)
                                }
                            }, ESport: {
                                toggleStake: (t, {data: e}) => {
                                    t.dispatch("toggleStake", e)
                                }, repeatTheBet: (t, {data: e}) => {
                                    t.dispatch("repeatTheBet", e)
                                }, chequeRedactOrder: (t, {data: e}) => {
                                    t.dispatch("chequeRedactOrder", e)
                                }, resize: (t, {data: e}) => {
                                    if (n) return;
                                    const i = e && e.height || window.innerHeight;
                                    t.dispatch("updateHeight", i)
                                }, updateUserBalance: (t, {data: e}) => {
                                    t.dispatch("updateUserBalance", e)
                                }, updateOddFormat: (t, {data: e}) => {
                                    t.dispatch("updateOddFormat", e)
                                }, updateTimeFormat: (t, {data: e}) => {
                                    t.dispatch("updateTimeFormat", e)
                                }, openBetSlip: (t, {data: e}) => {
                                    t.dispatch("openBetSlip", e)
                                }, setSportTournamentMode: (t, {data: e}) => {
                                    t.dispatch("setSportTournamentMode", e)
                                }, closeBetSlip: t => {
                                    t.dispatch("closeBetSlip", null)
                                }, changePageMode: (t, {data: e}) => {
                                    if ("-" === e) return;
                                    const i = "DESKTOP" === e, o = i ? 0 : 1, n = i ? 320 : null;
                                    t.dispatch("updateCloseModeVariant", o), t.dispatch("updateWidth", n)
                                }
                            }
                        }
                    }]
                }, p = await x.multiBoot(l, e.name, (() => {
                    s.remove(), a.remove()
                }));
                if (!n) {
                    const t = () => {
                        p.Betslip.dispatch("updateHeight", window.innerHeight)
                    };
                    window.addEventListener("resize", t), window.addEventListener("touchend", t), t()
                }
                return p
            }

            static async multiBoot(t, e, i) {
                return new Promise((async o => {
                    const {server: n, apps: a = [], communication: s = []} = t;
                    if (!t.globalSettings) {
                        t.isBetShop = "BetShop" === e;
                        const i = await I(t);
                        t.globalSettings = i.globalSettings, t.translations = i.translations
                    }
                    const r = {}, l = {}, p = {};
                    let d = 0;
                    a.forEach((c => {
                        const {appConfig: h, bootConfig: m, iframeConfig: g, method: u} = c,
                            f = Object.assign({server: n}, t, h), b = x[u](f, m, g), B = m.name;
                        b.then((t => {
                            r[B] = t, s.forEach((e => {
                                const {from: i, eventFrom: o, to: n, eventTo: a} = e;
                                i === B && t.addEventListener(o, (e => {
                                    const {data: o} = e;
                                    l[i] && (l[i].forEach((e => e(t))), l[i] = []);
                                    const s = x.createMultiBootEventToBehavior({eventTo: a, data: o});
                                    r[n] ? s(r[n]) : (l[n] || (l[n] = []), l[n].push(s))
                                }))
                            })), p[B] && p[B].forEach((({callback: e, data: i}) => {
                                e(t, i)
                            })), a.forEach((e => {
                                const i = (e.listen || {})[B];
                                i && Object.entries(i).map((([i, o]) => {
                                    t.addEventListener(i, (t => {
                                        r[e.bootConfig.name] ? o(r[e.bootConfig.name], t) : (p[e.bootConfig.name] || (p[e.bootConfig.name] = []), p[e.bootConfig.name].push({
                                            callback: o,
                                            data: t
                                        }))
                                    }))
                                }))
                            }))
                        })).then((() => {
                            if (d++, a.length === d) {
                                const t = v(r, e, i);
                                o(t)
                            }
                        }))
                    }))
                }))
            }

            static createMultiBootEventToBehavior({eventTo: t, data: e}) {
                const i = typeof t, o = "string" === i, n = "function" === i;
                return i => o ? i.dispatch(t, e) : n ? t(i, e) : null
            }

            static create() {
                return new x
            }

            static async configure() {
                return x.createInstanceAndCall("configure", arguments)
            }

            static async setup() {
                return x.createInstanceAndCall("setup", arguments)
            }

            static async boot(t, e) {
                this.validateBootConfig(e), await x.initSettings(t, e);
                const i = this.getCustomBootFunction(e);
                return i ? i(t, {...e, method: "boot"}) : x.bootBase(t, e)
            }

            static async initSettings(t, e) {
                let {name: i} = e;
                if (!t.globalSettings) {
                    t.isBetShop = "BetShop" === i;
                    const o = await I(t);
                    t.globalSettings = o.globalSettings, t.translations = o.translations, e.newBetSlip = !t.globalSettings.partner.EnableOldBetSlip
                }
                "Mobile" === i && "e-sport" === t.view && (e.newBetSlip = !1)
            }

            static async bootBase(t, e) {
                return x.createInstanceAndCall("boot", arguments)
            }

            static async bootIframe(t, e, i = {}) {
                await x.initSettings(t, e);
                const o = this.getCustomBootFunction(e);
                return o ? (t.requestFrame = T.requestFrame, o(t, {
                    ...e,
                    method: "bootIframe"
                })) : x.bootIframeBase(t, e, i)
            }

            static getBootableProjectsTypes(t = {}) {
                const e = t.name;
                return {
                    projectIsESport: "ESport" === e,
                    projectIsBetSlip: "Betslip" === e,
                    projectIsMobile: "Mobile" === e,
                    projectIsLatinoView: "LatinoView" === e,
                    projectIsAsianView: "AsianView" === e,
                    projectIsBetShop: "BetShop" === e,
                    projectIsEuropeanView: "EuropeanView" === e,
                    projectIsModernView: "ModernView" === e
                }
            }

            static validateBootConfig(t) {
                const {projectIsBetSlip: e} = this.getBootableProjectsTypes(t);
                if (e) {
                    const e = `${t.name} project should be boot with bootIframe.`;
                    throw new Error(e)
                }
            }

            static getCustomBootFunction(t) {
                const {
                    projectIsMobile: e,
                    projectIsLatinoView: i,
                    projectIsESport: o,
                    projectIsBetSlip: n,
                    projectIsBetShop: a,
                    projectIsEuropeanView: s,
                    projectIsModernView: r
                } = this.getBootableProjectsTypes(t);
                return {
                    [e && t.newBetSlip]: x.bootMobileWithNewBetslip,
                    [o && t.newBetSlip]: x.bootESport,
                    [i]: x.bootLatinoView,
                    [a]: x.bootBetShop,
                    [n]: x.bootBetSlip,
                    [s]: x.bootEuropeanView,
                    [r]: x.bootModernView
                }.true || null
            }

            static async bootIframeBase() {
                return x.createInstanceAndCall("bootIframe", arguments)
            }

            static async createInstanceAndCall(t, e) {
                const i = new x;
                return await i[t].apply(i, e), i.starter.addEventListener("onHttpCallError", (t => {
                    503 !== t.status && 403 !== t.status || M(!0)
                })), i
            }

            initHeaderElement() {
                const t = (this.iframeConfig || {}).headerElement || {}, e = t.clientHeight || 0;
                this.headerElement = t, this.headerHeight = e
            }

            reset() {
                this.destroy()
            }

            initProps() {
                this.bootConfig = null, this.appConfig = {}, this.appBootableConfig = {}, this.headerElement = null, this.headerHeight = null, this.iframeConfig = {}, this.removeScrollListener = Function.prototype
            }

            async bootIframe(t, e, i = {}) {
                return await this.configure(t, e, i), this.initHeaderElement(), this.setupIframeHeightAsNum(), await this.createIframe({scriptUrls: t.scriptUrls || []}), await this.setConfig(), await this.start(), this.startMessaging(), this
            }

            async createIframe(t = {}) {
                const {htmlTagAttrs: e = "", containerAttrs: i = "", scriptUrls: n = []} = t, a = {
                        width: "100%",
                        height: "1000px",
                        frameborder: "0",
                        allowfullscreen: "",
                        allow: "autoplay",
                        scrolling: "no"
                    }, s = this.appConfig, r = this.bootConfig, l = this.iframeConfig, p = this.configExtractor,
                    d = s.containerId, c = r.name, h = p.links, m = p.scripts;
                n.length && n.forEach((t => {
                    const e = document.createElement("script");
                    e.src = t, m.push(e)
                }));
                const g = `\n            <!DOCTYPE html>\n            <html ${e} lang='en'>\n                <head>\n                <title>${c}</title>\n                    ${h.map((t => t.outerHTML)).join("")}\n                </head>        \n                \n                <body>\n                    <div ${i} id='${d}'></div>                \n                    <div id='modals'></div>\n                    ${m.map((t => t.outerHTML)).join("")}\n                </body>\n            </html>\n        `;
                (["AsianView", "Mobile"].includes(c) || l.height) && delete a.scrolling;
                const u = document.createElement("iframe"), f = Object.assign({}, a, l);
                Object.entries(f).forEach((([t, e]) => u.setAttribute(t, e))), Object.assign(u.style, {
                    width: 0,
                    "min-width": "100%",
                    "min-height": "",
                    opacity: 0,
                    display: "block"
                });
                const b = document.getElementById(d) || document.createElement("div");
                if (!b) return console.warn(`Provided container id "${d}" is not in the DOM`);
                let B;
                if (o()) {
                    console.log("Safari detected"), b.appendChild(u);
                    const t = u.contentDocument;
                    t.open(), t.write(g), B = new Promise((e => {
                        t.addEventListener("DOMContentLoaded", (function i() {
                            t.removeEventListener("DOMContentLoaded", i), e()
                        }))
                    })), t.close()
                } else u.srcdoc = g, b.appendChild(u), B = new Promise((t => u.onload = t));
                await B, u.style.opacity = "1", this.iframe = u, this.iframeContainer = b, this.appConfig.isIframe = !0, this.appConfig.iframe = u
            }

            async boot(t = {}, e = {}) {
                return t.isIframe = !1, this.destroy(), await this.configure(t, e), await this.load(), await this.setConfig(), await this.start(), this.startMessaging(), this
            }

            startMessaging() {
                this.dynamicallyChangeIframeDimensions(), this.dispatchParentBoundingBoxOnScroll()
            }

            navigateTo(t) {
                this.dispatch("navigateTo", t)
            }

            dispatchParentBoundingBoxOnScroll() {
                if (!this.iframe) return;
                const t = () => this.dispatchParentBoundingBox();
                window.addEventListener("scroll", t), this.removeScrollListener = () => window.removeEventListener("scroll", t)
            }

            dispatchParentBoundingBox() {
                const t = this.getBoundingBoxes();
                this.dispatch("bounds", {bounds: t})
            }

            getBoundingBoxes() {
                const t = this.iframe, e = this.headerHeight, i = document.documentElement.getBoundingClientRect(),
                    o = t.getBoundingClientRect();
                return {
                    visibleArea: {
                        bottom: i.bottom,
                        height: i.height,
                        left: i.left,
                        right: i.right,
                        top: i.top,
                        width: i.width,
                        x: i.x,
                        y: i.y,
                        windowInnerHeight: window.innerHeight
                    },
                    sportIframe: {
                        bottom: o.bottom,
                        height: o.height,
                        left: o.left,
                        right: o.right,
                        top: o.top,
                        width: o.width,
                        x: o.x,
                        y: o.y
                    },
                    headerHeight: e
                }
            }

            dynamicallyChangeIframeDimensions() {
                this.iframe && this.addEventListener("changeDimensions", (t => {
                    t.sender && (this.setIframeHeightWithLimit(t.data), this.dispatchParentBoundingBox())
                }))
            }

            setupIframeHeightAsNum() {
                const t = this.iframeConfig.height;
                if (!t) return;
                if ("number" == typeof t) return this.iframeHeightAsNum = t;
                const e = `${t}`.match(/^[0-9]+/);
                this.iframeHeightAsNum = e && +e[0]
            }

            setIframeHeightWithLimit(t) {
                const e = this.iframeHeightAsNum, i = t.height, o = i > e ? e : i;
                this.setIframeHeight({height: o})
            }

            setIframeHeight(t) {
                const e = this.iframe, i = t.height;
                +i && (e.height = i + "px")
            }

            changeColors(t) {
                this.dispatchColorsChange.apply(this, arguments)
            }

            dispatchColorsChange(t) {
                this.dispatch("changeColors", {colors: t})
            }

            async setup(t, e) {
                await this.configure(t, e), await this.load(), await this.setConfig()
            }

            async configure(t, e, i = {}) {
                return this.appConfig = t, this.iframeConfig = i, this.initBootConfig(e), await x.initSettings(this.appConfig, this.bootConfig), await this.initAppBootableConfig(), this.finalizeAppConfig(), this.appBootableConfig
            }

            async load() {
                return await this.loader.load(this.appBootableConfig), this
            }

            start() {
                return this.starter.start(this)
            }

            setConfig() {
                return this.starter.setConfig(this)
            }

            init(t) {
                this.initDependencies(), this.initProps(t)
            }

            initDependencies() {
                this.configExtractor = new y, this.loader = new C, this.starter = new E, this.Utils = i
            }

            finalizeAppConfig() {
                const t = this.appConfig, {version: e, urlWithVersion: i} = this.configExtractor;
                m(t, {publicPath: `${i}/`, version: e})
            }

            async initAppBootableConfig() {
                this.appBootableConfig = await this.configExtractor.extract(this.appConfig, this.bootConfig)
            }

            initBootConfig(t = {}) {
                if (!t.name) throw new Error('Please provide application `name`, { name: "<APPLICATION NAME>" }');
                this.bootConfig = t
            }

            objToWindowOptions(t) {
                return JSON.stringify(t).replace(/["{}]/g, "").replace(/:/g, "=")
            }

            addEventListener(t, e) {
                return this.starter.addEventListener(t, e), this
            }

            removeEventListener(t, e) {
                return this.starter.removeEventListener(t, e), this
            }

            dispatch(t, e) {
                return this.starter.dispatchEvent(t, e), this
            }

            destroy() {
                this.removeScrollListener(), this.initProps(), this.loader.destroy(), this.starter.destroy(), this.configExtractor.destroy(), this.iframe && this.iframe.remove(), this.iframe = null
            }
        }

        var H = x;
        return e.default
    }()
}));